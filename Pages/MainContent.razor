@page "/{type?}/{sections?}/{subSections?}"
@using System.Net;
@using System.Net.Http;
@using System.Net.Http.Headers;
@using Microsoft.AspNetCore.Components.Authorization
@using Newtonsoft.Json;
@using System.Timers;
@using System.Text.RegularExpressions;
@using BlazorWasmPortfolioGhAction.Shared.Model;
@using BlazorWasmPortfolioGhAction.Store.Actions;
@using BlazorWasmPortfolioGhAction.Store.State;
@using Fluxor;
@inject IState<ContentState> contentState
@inject IDispatcher Dispatcher
@inject HttpClient Http;
@inject NavigationManager Navigation;
@inject IJSRuntime JSRuntime;
@* Using Authorize View to only load content when user is authenticated. The editor is disabled when not authenticated *@

<PageTitle>Wiki</PageTitle>
@* Using bootstrap container for layout on main content.  Using some grid layout elements *@
<div class="container-fluid mx-0 ps-0 mainContentContainer">
    @* Moved the searchBar marup and logic to a component so it's on all pages *@
    <SearchBar type="@type"
               SearchTermChanged="SearchTermChanged"
               IsSearchDisabled="false" />
    <div class="row mx-0 ps-0 gx-3">
        <div class="col">
            @* Toggle between the 2 editor types.  This can be moved to one of the other conditionals doing the same. *@
            @if (type != null)
            {
                <div class="ms-1 form-group form-check form-switch kudosTextToggle">
                    <label class="form-check-label" for="sliderToggle">Light Editor</label>
                    <input type="checkbox" class="form-check-input inputCheck" id="sliderToggle" @bind="inline" @onclick="(() => ClearIsEditingArray())" />
                </div>
            }
            @* Wtf is this block... really need to tidy this up.  Most of if can move to the main foreach loop conditionals *@
            @if (type != "all" && type != null && sections != "all" && subSections != "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@sections <small class="text-muted">@subSections </small></h1>
            }
            else if (type != "all" && sections != "all" && subSections == "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@type <small class="text-muted">@sections </small></h1>
            }
            else if (type != "all" && sections == "all" && type != "Search" && type != "add")
            {
                <h1 class="kudosTextTop">@type <small class="text-muted"></small></h1>
            }
            else if (type == "all")
            {
                <h1 class="kudosTextTop"></h1>
            }
            else if (type == "add")
            {
                <h1 class="kudosTextTop">Add New Section <small class="text-muted"></small></h1>
            }
            else if (type == "Search")
            {
                <h1 class="kudosTextTop">Search Results <small class="text-muted"></small></h1>
            }
            @* Show a loading message before API call is complete *@
            @* Should also add failure case if the API call returns 404 *@
            @*add back 'isContentLoaded == false || ' to conditional*@
            @if (contentState.Value.Contents == null || type == null)
            {
                <div class="introductionBody">
                    <!-- Begin: Home -->
                    <div class="start_light"></div>
                    <div id="header">
                        <div class="container">
                            <nav class="nav">
                                <h2 class="title-content">PORTFOLIO</h2>
                            </nav>
                            <div class="header-content">
                                <div class="header-text">
                                    <h1>Khoi Nguyen Minh Duc</h1>
                                    <p>.NET Developer</p>
                                    <div class="grid-container justify-content-center">
                                        <div class="email-button">
                                            <a href="mailto:khoi.duc.dev@gmail.com" class="email-link">
                                                <h5>Contact Me</h5>
                                                <img src="envelope-blue.svg" alt="email" class="email-icon">
                                            </a>
                                        </div>
                                        <div class="google-drive-button">
                                            <a href="MyResume" class="google-drive-link">
                                                <h5>My Resume</h5>
                                                <img src="googledrive-blue.svg" alt="Resume site" class="google-drive-icon">
                                            </a>
                                        </div>
                                        <div class="download-file-button">
                                            <a href="Dissertation/CV" class="download-file-button-link">
                                                <h5>My CV</h5>
                                                <img src="downloadfile-blue.svg" alt="Download file" class="download-file-icon">
                                            </a>
                                        </div>
                                    </div>
                                </div>
                                <div class="header-image">
                                    <img src="/avt-men.png" alt="Profile Image">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            }
            else
            {
                <AuthorizeView>
                    <Authorized>
                        @{
                            var count = 0;
                            var username = @context.User.Identity!.Name;
                        }
                        <div class="mainTable">
                            <table class="table rounded table-dark @(inline == true ? "border-bottom" : "table-borderless table-striped")">
                                @* @(inline == true ? "" : "") *@
                                <tbody>
                                    @if (type == "Search")
                                    {
                                        foreach (var item in searchResults
                                        .OrderByDescending(x => x.Score)
                                        .Select((searchResult, index) => new { searchResult, index }))
                                        {
                                            var localCount = count;
                                            int indexParsed = item.searchResult.Content.id;
                                            <WikiBlock inline="@inline"
                                                       matchTypeSectionsSubSections="false"
                                                       matchTypeSections="false"
                                                       matchType="false"
                                                       type="@type"
                                                       sections="@sections"
                                                       subSections="@subSections"
                                                       TinyAPIKey="@TinyAPIKey"
                                                       count="@count"
                                                       indexParsed="@indexParsed"
                                                       username="@username" />
                                            @* localCount=localCount *@
                                            <p>Search Score: @item.searchResult.Score</p>
                                            @* Increment global count *@
                                            count++;
                                        }
                                    }
                                    else if (type == "add" && contentState.Value.IsEditing[0] == true && contentState.Value.Contents != null)
                                    {
                                        <WikiBlock inline="@inline"
                                                   matchTypeSectionsSubSections="false"
                                                   matchTypeSections="false"
                                                   matchType="false"
                                                   type="@type"
                                                   sections="@sections"
                                                   subSections="@subSections"
                                                   TinyAPIKey="@TinyAPIKey"
                                                   count="0"
                                                   indexParsed=0
                                                   username="@username" />
                                    }
                                    else
                                    {
                                        @* Pragmatically populate the table using my custom object array *@
                                        @foreach (var item in contentState.Value.Contents
                                       .OrderBy(x => x.page)
                                       .ThenBy(x => x.section)
                                       .ThenBy(x => x.subSection)
                                       .Select((ContentHolder, index) => new { ContentHolder, index }))
                                        {
                                            bool contentNotNull = contentState.Value.Contents[item.index].page != null
                                            && contentState.Value.Contents[item.index].section != null
                                            && contentState.Value.Contents[item.index].subSection != null
                                            && contentState.Value.Contents[item.index].content != null;

                                            bool matchTypeSectionsSubSections = type == contentState.Value.Contents[item.index].page
                                            && sections == contentState.Value.Contents[item.index].section
                                            && subSections == contentState.Value.Contents[item.index].subSection;

                                            bool matchTypeSections = type == contentState.Value.Contents[item.index].page
                                            && sections == contentState.Value.Contents[item.index].section
                                            && subSections == "all";

                                            bool matchType = type == contentState.Value.Contents[item.index].page
                                            && sections == "all";

                                            int indexParsed = contentState.Value.Contents[item.index].id;

                                            @if (item.ContentHolder != null)
                                            {

                                                @if (matchTypeSectionsSubSections && contentNotNull)
                                                {
                                                    var localCount = count;

                                                    <WikiBlock inline="@inline"
                                                               matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                               matchTypeSections="@matchTypeSections"
                                                               matchType="@matchType"
                                                               type="@type"
                                                               sections="@sections"
                                                               subSections="@subSections"
                                                               TinyAPIKey="@TinyAPIKey"
                                                               count="@count"
                                                               indexParsed="@indexParsed"
                                                               username="@username" />

                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else if (matchTypeSections && contentNotNull)
                                                {
                                                    var localCount = count;

                                                    <WikiBlock inline="@inline"
                                                               matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                               matchTypeSections="@matchTypeSections"
                                                               matchType="@matchType"
                                                               type="@type"
                                                               sections="@sections"
                                                               subSections="@subSections"
                                                               TinyAPIKey="@TinyAPIKey"
                                                               count="@count"
                                                               indexParsed="@indexParsed"
                                                               username="@username" />

                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else if (matchType || type == null && contentNotNull)
                                                {
                                                    var localCount = count;

                                                    <WikiBlock inline="@inline"
                                                               matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                               matchTypeSections="@matchTypeSections"
                                                               matchType="@matchType"
                                                               type="@type"
                                                               sections="@sections"
                                                               subSections="@subSections"
                                                               TinyAPIKey="@TinyAPIKey"
                                                               count="@count"
                                                               indexParsed="@indexParsed"
                                                               username="@username" />

                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else if (type == "all" && contentNotNull)
                                                {
                                                    var localCount = count;

                                                    <WikiBlock inline="@inline"
                                                               matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                               matchTypeSections="@matchTypeSections"
                                                               matchType="@matchType"
                                                               type="@type"
                                                               sections="@sections"
                                                               subSections="@subSections"
                                                               TinyAPIKey="@TinyAPIKey"
                                                               count="@count"
                                                               indexParsed="@indexParsed"
                                                               username="@username" />

                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else
                                                {
                                                    if (contentState.Value.Contents[item.index].page == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing title for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                    }
                                                    else if (contentState.Value.Contents[item.index].section == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing section name for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                    }
                                                    else if (contentState.Value.Contents[item.index].subSection == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing subSection name for something in section: " + contentState.Value.Contents[item.index].section)
                                                    }
                                                    else if (contentState.Value.Contents[item.index].content == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing content for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                Console.WriteLine("Suppressing error?");
                                            }
                                        }
                                    }
                                    @if (type == "add")
                                    {
                                        @if (contentState.Value.Contents == null)
                                        {
                                            <p><em> </em></p>
                                        }
                                        else
                                        {
                                            contentState.Value.IsEditing[0] = false;
                                            <div class="bg-light text-primary container-fluid">
                                                <div class="row">
                                                    <div class="col-6">
                                                        @* Dropdown for section type *@
                                                        <div class="form-group">
                                                            <label class="form-label bg-light text-dark" for="typeDropdown">Select Type:</label>
                                                            <select class="form-control form-control-dark bg-light text-primary border-primary" id="typeDropdown" @bind="typeDropdown">
                                                                <option value="Default" disabled selected>Select a type</option>
                                                                @foreach (var group in contentState.Value.Contents!.GroupBy(ch => ch.page))
                                                                {
                                                                    <option value="@group.First().page">@group.Key</option>
                                                                }
                                                                <option value="Add">Add New</option>
                                                            </select>
                                                            @if (typeDropdown == "Add")
                                                            {
                                                                <input type="text" class="form-control form-control-dark bg-light text-primary border-primary mt-2" placeholder="Enter new type name" @bind="newTypeDropdown" />
                                                            }
                                                        </div>
                                                        @* Text field for section name *@
                                                        <div class="form-group">
                                                            <label class="form-label bg-light text-dark" for="sectionDropdown">Select Section:</label>
                                                            <select class="form-control form-control-dark bg-light text-primary border-primary" id="sectionDropdown" @bind="sectionName">
                                                                <option value="Default" disabled selected>Select a type, then section</option>
                                                                @foreach (var group in contentState.Value.Contents!.Where(ch => ch.page == typeDropdown).GroupBy(ch => ch.section))
                                                                {
                                                                    <option value="@group.First().section">@group.Key</option>
                                                                }
                                                                <option value="Add">Add New</option>
                                                            </select>
                                                            @if (sectionName == "Add")
                                                            {
                                                                <input type="text" class="form-control form-control-dark bg-light text-primary border-primary mt-2" placeholder="Enter new section name" @bind="newSectionName" />
                                                            }
                                                        </div>
                                                        @* Text field for subSection name *@
                                                        <div class="form-group bg-light text-primary">
                                                            <label class="form-label bg-light text-dark mt-1" for="sectionContent">Select subSection:</label>
                                                            <input type="text" class="form-control form-control-dark bg-light text-primary border-primary" id="sectionContent" placeholder="Name of the new subSection" @bind="subSectionName">
                                                        </div>
                                                        @* Add section button *@
                                                        <button class="btn btn-outline-primary mt-2" @onclick="(() => AddNewSection(username!))">Add New subSection</button>
                                                    </div>
                                                    <div class="col-6">
                                                        @* Spacing *@
                                                    </div>
                                                </div>
                                            </div>
                                        }
                                    }
                                </tbody>
                            </table>
                        </div>
                    </Authorized>
                    <NotAuthorized>
                        @{
                            var count = 0;
                        }
                        <div class="mainTable">
                            <table class="table rounded table-dark @(inline == true ? "border-bottom" : "table-borderless table-striped")">
                                @* @(inline == true ? "" : "") *@
                                <tbody>
                                    @* Pragmatically populate the table using my custom object array *@
                                    @if (type == "Search")
                                    {
                                        foreach (var item in searchResults
                                        .OrderByDescending(x => x.Score)
                                        .Select((searchResult, index) => new { searchResult, index }))
                                        {
                                            var localCount = count;
                                            int indexParsed = item.searchResult.Content.id;
                                            <WikiBlockNoAuth inline="@inline"
                                                             matchTypeSectionsSubSections="false"
                                                             matchTypeSections="false"
                                                             matchType="false"
                                                             type="@type"
                                                             sections="@sections"
                                                             subSections="@subSections"
                                                             count="@count"
                                                             indexParsed="@indexParsed" />
                                            @* localCount=localCount *@
                                            <p>Search Score: @item.searchResult.Score</p>
                                            @* Increment global count *@
                                            count++;
                                        }
                                    }
                                    else
                                    {
                                        @foreach (var item in contentState.Value.Contents
                                       .OrderBy(x => x.page)
                                       .ThenBy(x => x.section)
                                       .ThenBy(x => x.subSection)
                                       .Select((ContentHolder, index) => new { ContentHolder, index }))
                                        {
                                            bool contentNotNull = contentState.Value.Contents[item.index].page != null
                                            && contentState.Value.Contents[item.index].section != null
                                            && contentState.Value.Contents[item.index].subSection != null
                                            && contentState.Value.Contents[item.index].content != null;

                                            bool matchTypeSectionsSubSections = type == contentState.Value.Contents[item.index].page
                                            && sections == contentState.Value.Contents[item.index].section
                                            && subSections == contentState.Value.Contents[item.index].subSection;

                                            bool matchTypeSections = type == contentState.Value.Contents[item.index].page
                                            && sections == contentState.Value.Contents[item.index].section
                                            && subSections == "all";

                                            bool matchType = type == contentState.Value.Contents[item.index].page
                                            && sections == "all";

                                            int indexParsed = contentState.Value.Contents[item.index].id;

                                            @if (item.ContentHolder != null)
                                            {

                                                @if (matchTypeSectionsSubSections && contentNotNull)
                                                {
                                                    var localCount = count;
                                                    <WikiBlockNoAuth inline="@inline"
                                                                     matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                                     matchTypeSections="@matchTypeSections"
                                                                     matchType="@matchType"
                                                                     type="@type"
                                                                     sections="@sections"
                                                                     subSections="@subSections"
                                                                     count="@count"
                                                                     localCount=localCount
                                                                     indexParsed="indexParsed" />
                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else if (matchTypeSections && contentNotNull)
                                                {
                                                    var localCount = count;
                                                    <WikiBlockNoAuth inline="@inline"
                                                                     matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                                     matchTypeSections="@matchTypeSections"
                                                                     matchType="@matchType"
                                                                     type="@type"
                                                                     sections="@sections"
                                                                     subSections="@subSections"
                                                                     count="@count"
                                                                     localCount=localCount
                                                                     indexParsed="indexParsed" />
                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else if ((matchType || type == null) && contentNotNull)
                                                {
                                                    var localCount = count;
                                                    <WikiBlockNoAuth inline="@inline"
                                                                     matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                                     matchTypeSections="@matchTypeSections"
                                                                     matchType="@matchType"
                                                                     type="@type"
                                                                     sections="@sections"
                                                                     subSections="@subSections"
                                                                     count="@count"
                                                                     localCount=localCount
                                                                     indexParsed="indexParsed" />
                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else if (type == "all" && contentNotNull)
                                                {
                                                    var localCount = count;
                                                    <WikiBlockNoAuth inline="@inline"
                                                                     matchTypeSectionsSubSections="@matchTypeSectionsSubSections"
                                                                     matchTypeSections="@matchTypeSections"
                                                                     matchType="@matchType"
                                                                     type="@type"
                                                                     sections="@sections"
                                                                     subSections="@subSections"
                                                                     count="@count"
                                                                     localCount=localCount
                                                                     indexParsed="indexParsed" />
                                                    @* Increment global count *@
                                                    count++;
                                                }
                                                else
                                                {
                                                    if (contentState.Value.Contents[item.index].page == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing title for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                    }
                                                    else if (contentState.Value.Contents[item.index].section == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing section name for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                    }
                                                    else if (contentState.Value.Contents[item.index].subSection == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing subSection name for something in section: " + contentState.Value.Contents[item.index].section)
                                                    }
                                                    else if (contentState.Value.Contents[item.index].content == null)
                                                    {
                                                        @JSRuntime.InvokeVoidAsync("alert", "Warning, missing content for subSection: " + contentState.Value.Contents[item.index].subSection)
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                Console.WriteLine("Suppressing error?");
                                            }
                                        }
                                    }
                                </tbody>
                            </table>
                        </div>
                    </NotAuthorized>
                </AuthorizeView>
            }
        </div>
    </div>
</div>

@code {
    @* Declare custom object array will change this for a dictionary *@
    public List<SearchResult> searchResults = new List<SearchResult>();
    public string? searchTerm { get; set; }
    private string Logo = "Logo.png";
    public string loadingMSG = "Loading...";
    @* Declare var for current user selection *@
    [Parameter]
    public string? type { get; set; }
    [Parameter]
    public string? sections { get; set; }
    [Parameter]
    public string? subSections { get; set; }
    @* Declare Global Vars *@
    private bool? inline { get; set; } = true;
    //private List<ContentHolder> initialContent;
    //private bool[]? IsEditing;
    private string? typeDropdown;
    private string? newTypeDropdown;
    private string? sectionName;
    private string? subSectionName;
    private string? newSectionName;
    private int sectionBeingEdited;
    private string TinyAPIKey = "";
    @* Declare/Initialize variables for API communication *@
    private string? commitText = "Test From Wiki";

    private ElementReference cardsWrapper; // This holds reference to our cards container
    private int currentIndex = 0; // Keeps track of current slide
    private int totalCards => cards.Count;
    private string myStyle = ""; // Style string that we'll bind to
    private double cardWidth = 0;
    private int visibleCards = 0;
    private string transitionStyle = "transition: transform 0.3s ease;";
    private CancellationTokenSource cts = new CancellationTokenSource();
    private List<Card> DisplayCards => cards.Concat(cards.Take(visibleCards)).ToList();
    private List<Card> cards = new List<Card>
    {
        new Card
        {
            Title = "AI Assistant!",
            Text = "Search the site faster with AI",
            Link = "/navBot",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "My Novel Genetic Algorithm",
            Text = "A Genetic Algorithm I developed myself.",
            Link = "/SvgDiagramEditor",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "ChatBot!",
            Text = "Try out GPT-4 for free!",
            Link = "/chat",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "Wiki!",
            Text = "View or edit articles about me!",
            Link = "/all",
            ButtonText = "Try It Out!"
        },
        new Card
        {
            Title = "My Dissertation",
            Text = "Read my dissertation on AI Interpretability!",
            Link = "/Dissertation/Transcript",
            ButtonText = "Read Here!"
        },
        new Card
        {
            Title = "C.V.",
            Text = "Read my CV to see my qualifications!",
            Link = "/Dissertation/CV",
            ButtonText = "Read Here!"
        },
        new Card
        {
            Title = "Old Evolution Sim",
            Text = "My first attempt at implementing a basic Genetic Algorithm",
            Link = "/EvolutionTF",
            ButtonText = "Try It Out!"
        },
    };

    private IJSObjectReference? mainContentModule;

    [Inject] public AuthenticationStateProvider? AuthenticationStateProvider { get; set; }

    @* Initialize page.  Using Async initialization as I want to load content from API before rendering *@
    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("MainContent.razor initialized");
        try
        {
            @* Call method to make GET request *@
            //await Task.WhenAll(GetAllContentFromGitHubRepo<ContentHolder>(false));
            contentState.StateChanged += ContentStateChanged;
            @* Initialize control variables after populating contentState.Value.Contents *@

            @* Add event handler to navigation change event to reset IsEditing array *@
            Navigation.LocationChanged += LocationChanged!;
            base.OnInitialized();
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
            loadingMSG += "Error Loading Content: " + ex.Message;
            StateHasChanged();
        }

        while (true)
        {
            try
            {
                await Task.Delay(5000, cts.Token);  // Use the token here
            }
            catch (TaskCanceledException)
            {
                // Reset the CancellationTokenSource for future delays
                await Task.Delay(150);
                cts = new CancellationTokenSource();
            }
            SlideCards();
            StateHasChanged();
        }
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            mainContentModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/MainContent.razor.js");
            await mainContentModule.InvokeVoidAsync("initializeStarfield");
        }
    }
    private void SlideCards()
    {
        currentIndex++;

        // Check if the next slide would be the start (after the duplicate cards are fully in view)
        if (currentIndex + visibleCards == totalCards + visibleCards)
        {
            cts.Cancel();  // Reset the delay
        }

        // Now handle the jump back to the start
        if (currentIndex + visibleCards > totalCards + visibleCards)
        {
            currentIndex = 0;
            myStyle = $"transform: translateX(0px);";
            StateHasChanged();
            return;
        }

        myStyle = $"transform: translateX({currentIndex * -cardWidth}px); {transitionStyle}";
    }


    private async void ContentStateChanged(object? sender, EventArgs e)
    {
        if (contentState.Value.FileCount == contentState.Value.LoadedFilesCount)
        {
            await InvokeAsync(StateHasChanged); // Update the UI
            await Task.Delay(500);
            cardWidth = await JSRuntime.InvokeAsync<double>("carouselHelper.getCardWidth");
            visibleCards = await JSRuntime.InvokeAsync<int>("carouselHelper.getVisibleCards");
            await JSRuntime.InvokeVoidAsync("carouselHelper.addResizeListener", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("registerComponentInstance", DotNetObjectReference.Create(this));

        }
    }

    [JSInvokable("RecalculateSizes")]
    public async Task RecalculateSizes()
    {
        currentIndex = 0;
        myStyle = $"transform: translateX(0px);";
        StateHasChanged();
        await Task.Delay(500);
        cardWidth = await JSRuntime.InvokeAsync<double>("carouselHelper.getCardWidth");
        visibleCards = await JSRuntime.InvokeAsync<int>("carouselHelper.getVisibleCards");
    }

    public void Dispose()
    {
        JSRuntime.InvokeVoidAsync("carouselHelper.unregisterComponentInstance");
        contentState.StateChanged -= ContentStateChanged;
    }


    public class Card
    {
        public string? Title { get; set; }
        public string? Text { get; set; }
        public string? Link { get; set; }
        public string? ButtonText { get; set; }
    }

    protected override async void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            //Code to execute once
            //await GetAuthenticationState();
        }
        base.OnAfterRender(firstRender);
    }

    @* Checks current authentication state *@

    private void LocationChanged(object sender, LocationChangedEventArgs e)
    {
        ClearIsEditingArray();
    }

    @* Method called in a few places, but should close all open editors, and save any content thats being edited currently *@
    private void ClearIsEditingArray()
    {
        Dispatcher.Dispatch(new ResetIsEditingAction());

    }
    @* Detects when text changes in the search component, and triggers search methods *@
    private void SearchTermChanged(string searchPhrase)
    {
        Console.WriteLine("Search Term Changed In Component!");
        searchTerm = searchPhrase;
        if (searchTerm!.Length > 1)
        {
            @* Not a good solution, I need to add entries to contentState.Value.Contents that can be searched through, but don't get rendered. *@
            if (string.Equals(searchTerm, "CV", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/CV");
            }
            else if (string.Equals(searchTerm, "Transcript", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/Transcript");
            }
            else if (string.Equals(searchTerm, "Degree", StringComparison.OrdinalIgnoreCase))
            {
                Navigation.NavigateTo($"/Dissertation/Degree");
            }
            else
            {
                searchResults = PerformSearch(searchTerm, contentState.Value.Contents);
            }
        }
        if (type != "Search")
        {
            if (searchTerm!.Length > 1)
            {
                Navigation.NavigateTo($"/Search");
            }
        }
        else
        {
            if (String.IsNullOrWhiteSpace(searchTerm))
            {
                Navigation.NavigateTo($"/all");
            }
        }

    }
    @* Build a list of search results including scores *@
    private List<SearchResult> PerformSearch(string searchTerm, List<ContentHolder> contentList)
    {
        var results = new List<SearchResult>();

        for (int i = 0; i < contentList.Count; i++)
        {
            var content = contentList[i];
            int score = CalculateMatchScore(searchTerm, content);
            if (score > 0)
            {
                results.Add(new SearchResult { Score = score, Content = content });
            }
        }
        return results.OrderByDescending(r => r.Score).ToList();
    }

    @* Calculate score for each item in contentState.Value.Contents.  Might need to play with the given scores for each match type *@
    public int CalculateMatchScore(string searchTerm, ContentHolder content)
    {
        int score = 0;
        // Normalize search term
        searchTerm = Regex.Replace(searchTerm.Trim(), @"\p{P}", "").ToLower();

        // Split the search term into words
        var searchWords = searchTerm.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Strip HTML tags from content and normalize
        var strippedContent = Regex.Replace(content.content, "<.*?>", String.Empty);
        strippedContent = Regex.Replace(strippedContent, @"\p{P}", "").ToLower();

        // Split the content into words
        var contentWords = strippedContent.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Normalize title words
        var title = $"{content.page} {content.section} {content.subSection}";
        title = Regex.Replace(title, "<.*?>", String.Empty);
        title = Regex.Replace(title, @"\p{P}", "").ToLower();

        var titleWords = title.Split(' ').Where(word => !string.IsNullOrEmpty(word));

        // Check if the entire search term appears in the content or title
        if (strippedContent.Contains(searchTerm) || title.Contains(searchTerm))
        {
            score += 4;
        }

        // Check each word in the content
        foreach (var word in contentWords)
        {
            if (searchWords.Any(searchWord => string.Equals(word, searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 2;
            }
            else if (searchWords.Any(searchWord => word.Contains(searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 1;
            }
        }

        // Check each word in the title
        foreach (var word in titleWords)
        {
            if (searchWords.Any(searchWord => string.Equals(word, searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 3;
            }
            else if (searchWords.Any(searchWord => word.Contains(searchWord, StringComparison.OrdinalIgnoreCase)))
            {
                score += 2;
            }
        }

        return score;
    }

    private void RefreshMe()
    {
        StateHasChanged();
    }

    @* Add a new object to my array from user input *@
    private async Task AddNewSection(string username)
    {
        @* Using data binding to tie user selection to these vars *@
        string? subName = subSectionName;
        string? newType = newTypeDropdown;
        string? newName = newSectionName;
        string finalType;
        string finalName;
        if (typeDropdown == "Add")
        {
            finalType = newTypeDropdown!;
        }
        else
        {
            finalType = typeDropdown!;
        }
        if (sectionName == "Add")
        {
            finalName = newSectionName!;
        }
        else
        {
            finalName = sectionName!;
        }
    }
}